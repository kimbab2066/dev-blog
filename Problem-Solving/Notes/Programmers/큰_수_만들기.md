# 오답노트: 큰 수 만들기

- 플랫폼: 프로그래머스
- 문제 링크: [https://school.programmers.co.kr/learn/courses/30/lessons/42883]

---

## 1. 문제 설명
[numbers 배열이 주어지면 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 수를 구하는 문제]

---

## 2. 내가 작성한 코드
```python
def solution(number, k):
    stack = []
    n = len(number)
    for i in range(n):
        while stack and k and stack[-1] < number[i]:
            stack.pop()
            k-=1
        stack.append(number[i])
    return ''.join(stack)
```

---

## 3. 실패 원인
- **반례 미처리**: 내림차순 순열(예: `654321`)일 경우 `k`가 그대로 남아, 제거해야 할 숫자가 처리되지 않는 문제가 발생한다.
  - 원래 코드는 `stack.pop()` 조건이 충족되지 않을 경우를 고려하지 않았기 때문에, 내림차순 숫자에서는 `stack`이 그대로 유지된다.
  - 따라서 루프 종료 후 남아 있는 `k`만큼 뒤에서 제거해야 한다.

---

## 4. 수정된 코드

```python
def solution(number, k):
    stack = []
    n = len(number)
    for i in range(n):
        while stack and k and stack[-1] < number[i]:
            stack.pop()
            k -= 1
        stack.append(number[i])
    if k > 0: stack = stack[:-k]
    return ''.join(stack)
```

---

## 5. 배운 점
- **내림차순 수열 처리의 중요성**:
  - 숫자가 내림차순으로 배열된 경우, 제거되지 않은 숫자를 처리하기 위해 루프 종료 후 `stack`에서 뒤에서부터 `k`개의 숫자를 제거해야 한다.
  - 이를 통해 모든 경우의 수를 정확히 처리할 수 있다.

- **스택 활용의 효율성**:
  - 스택 자료구조를 활용하여 매번 최적의 숫자를 남기도록 관리하면, 반복문을 통해 효율적으로 문제를 해결할 수 있다.

- **조건 추가로 로직 보완**:
  - `while` 조건에서 `stack`이 비어 있지 않고(`stack`), 제거 횟수가 남아 있으며(`k`), 현재 숫자가 `stack`의 마지막 숫자보다 클 경우(`stack[-1] < number[i]`)만 실행되도록 한다.
  - 추가적으로, 반복문 이후 `k > 0`인 경우를 별도로 처리해야 한다.

---

## 6. 풀이의 이유

### 1. 탐욕적 선택 속성 (Greedy Choice Property)
- 문제는 각 자리에서 숫자를 선택하거나 제거할 때, **현재 단계에서 가장 최적인 선택**을 반복합니다.
- 작은 숫자를 제거함으로써 더 큰 숫자가 앞으로 오게 하며, 이 과정이 전체 결과에 영향을 미칩니다.
- 현재 선택이 이후 선택에 영향을 주더라도, **작은 숫자를 제거하는 탐욕적인 선택이 최적의 결과를 보장**합니다.

#### 예시:
입력 `number = "4177252841", k = 4`
1. `4`는 유지 (다음 숫자 `1`보다 크기 때문).
2. `1`은 제거 (다음 숫자 `7`보다 작기 때문).  
이와 같은 탐욕적 선택을 반복하여 최종적으로 "775841"을 얻습니다.

---

### 2. 최적 부분 구조 (Optimal Substructure)
- 문제를 작은 부분 문제로 나눌 수 있으며, 각 부분 문제의 해가 전체 문제의 해를 구성합니다.
- 특정 자리의 숫자를 제거한 뒤 남은 숫자에서 동일한 과정을 반복하여 최적의 결과를 도출합니다.
- 각 부분 문제의 해가 최적이라는 점에서 그리디 알고리즘의 적용 조건을 충족합니다.

---

### 3. 왜 그리디인가?
- **모든 선택이 최적의 결과로 이어짐**: 숫자를 제거하는 과정에서 항상 현재 가장 작은 값을 제거하므로 전체적으로 가장 큰 수를 만들 수 있습니다.
- **효율성**:  
  - 완전 탐색 방식은 모든 조합을 계산하므로 비효율적입니다.
  - 그리디 방식은 한 번의 탐색으로 최적의 결과를 도출하므로 시간 복잡도를 줄일 수 있습니다.

---

### 4. 결론
- 작은 숫자를 제거해 큰 숫자를 앞으로 배치하는 탐욕적 선택이 항상 최적의 결과를 보장하므로, 이 문제는 **그리디 알고리즘**으로 해결할 수 있습니다.

